use super::prelude::*;

/// Handles the FUSE `write` operation.
///
/// This function implements the "cache" part of the "cache-on-write" strategy.
/// Instead of contacting the server on every write, this function is designed
/// to be extremely fast.
///
/// It stores the incoming `data` block and its `offset` directly into an
/// in-memory `HashMap` (`fs.open_files`) associated with the file handle (`fh`).
///
/// The actual upload to the server is deferred until the `release` function is called.
///
/// # Arguments
/// * `fs` - The mutable `RemoteFS` state.
/// * `fh` - The file handle (generated by `create` or `open`) that identifies the
///   in-memory buffer.
/// * `offset` - The byte offset within the file to write the data to.
/// * `data` - The block of bytes to be cached.
/// * `reply` - The reply object to send the number of bytes written back to the kernel.
pub fn write(
    fs: &mut RemoteFS,
    _req: &Request<'_>,
    _ino: u64,
    fh: u64,
    offset: i64,
    data: &[u8],
    _write_flags: u32,
    _flags: i32,
    _lock_owner: Option<u64>,
    reply: ReplyWrite,
) {
    // Find the in-memory buffer for this file handle
    if let Some(open_file) = fs.open_files.get_mut(&fh) {
        // Store a copy of the data in the buffer at the specified offset
        open_file.buffer.insert(offset, data.to_vec());
        // Immediately reply to the kernel
        reply.written(data.len() as u32);
    } else {
        // This file handle isn't in our write cache. This is a critical error.
        reply.error(EBADF); // Bad File Descriptor
    }
}

/// Handles the FUSE `release` operation (file close).
///
/// This is the most critical part of the write-caching strategy.
/// When a file handle is released, this function "flushes" the cached writes
/// to the server by performing a full "Read-Modify-Write" cycle:
///
/// 1. Fetches (`GET`) the file's current content from the server.
/// 2. Merges all data blocks from the in-memory cache (`open_file.buffer`)
///    with the original content, applying them at their correct offsets. This
///    correctly handles appends, overwrites, and sparse writes.
/// 3. Uploads (`PUT`) the complete, merged file back to the server.
/// 4. Invalidates the attribute cache for the inode.
///
/// # Arguments
/// * `fs` - The mutable `RemoteFS` state.
/// * `ino` - The inode of the file (used for cache invalidation).
/// * `fh` - The file handle to find and flush from the `open_files` cache.
/// * `reply` - The reply object to send success or an error code.
pub fn release(
    fs: &mut RemoteFS,
    _req: &Request<'_>,
    ino: u64,
    fh: u64,
    _flags: i32,
    _lock_owner: Option<u64>,
    _flush: bool,
    reply: ReplyEmpty,
) {
    // Attempt to remove the write buffer from the cache.
    // If it doesn't exist, this was probably a read-only handle, so we're done.
    if let Some(open_file) = fs.open_files.remove(&fh) {

        // If no data was written (e.g., `touch` or `cat > file`), do nothing.
        // The empty file was already created by `create`.
        if open_file.buffer.is_empty() {
            reply.ok();
            return;
        }

        // 1. Download the current content
        let old_content_result = fs.runtime.block_on(
            api_client::get_file_content_from_server(&fs.client, &open_file.path)
        );

        // Start with the old content, or an empty Vec if the file is new/empty
        let mut new_data_vec = match old_content_result {
            Ok(bytes) => bytes.to_vec(),
            Err(_) => Vec::new(),
        };

        // 2. Apply all cached modifications
        for (offset, data) in open_file.buffer {
            let start = offset as usize;
            let end = start + data.len();
            // Automatically resize the vector if the write is past the end of the file
            if end > new_data_vec.len() {
                new_data_vec.resize(end, 0);
            }
            new_data_vec[start..end].copy_from_slice(&data);
        }

        // 3. Upload the new, merged content
        let put_result = fs.runtime.block_on(
            api_client::put_file_content_to_server(
                &fs.client,
                &open_file.path,
                Bytes::from(new_data_vec) // Convert Vec<u8> to Bytes
            )
        );

        match put_result {
            Ok(_) => {
                // Invalidate the attribute cache so the next `ls -l` shows the new size
                fs.attribute_cache.remove(&ino);
                reply.ok();
            }
            Err(e) => {
                eprintln!("[FUSE CLIENT] Critical error during PUT in release: {:?}", e);
                reply.error(EIO);
            }
        }
    } else {
        // This was a read-only file handle, or one we didn't cache.
        // Nothing to do.
        reply.ok();
    }
}

/// Handles the FUSE `flush` operation.
///
/// In this implementation, `flush` is a no-op (it does nothing).
/// All write-caching logic is handled in `release` when the file handle is
/// fully closed, not during intermediate `flush` calls.
///
/// We simply reply `ok` to acknowledge the call.
pub fn flush(_fs: &mut RemoteFS, _req: &Request<'_>, _ino: u64, _fh: u64, _lock_owner: u64, reply: ReplyEmpty) {
    reply.ok();
}